# Creating the Service Account

We've configured Vault to allow a service account called `demo-app` to authenticate and read
our secret. Now we need to create that service account in Kubernetes.

## Why Service Accounts?

In Kubernetes, service accounts provide an identity for processes running in pods. When a pod
needs to interact with external services (like Vault), it uses its service account's token
to prove its identity.

The Vault Kubernetes auth method validates these tokens by calling back to the Kubernetes API.
This is why we created the token reviewer service account in the Authentication chapter - Vault
uses it to verify that service account tokens are legitimate.

## Service Account Tokens

Prior to Kubernetes 1.24, service account tokens were automatically created as secrets. However,
this changed for security reasons - tokens are now generated on-demand with shorter lifetimes.

For the Vault Secrets Operator to work, we need a long-lived token that it can use to authenticate
with Vault on behalf of our workload. We'll create this explicitly using a secret with the
`kubernetes.io/service-account-token` type.

<Task id="create_service_account">

Create a file called `service-account.yaml` with the following content and apply it using
kubectl:

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: demo-app
  namespace: default
---
apiVersion: v1
kind: Secret
metadata:
  name: demo-app-token
  namespace: default
  annotations:
    kubernetes.io/service-account.name: demo-app
type: kubernetes.io/service-account-token
```

This creates:
- A service account named `demo-app`
- A secret containing a long-lived token for that service account

</Task>

## Understanding the Token Secret

The token secret we created has a special type: `kubernetes.io/service-account-token`. When
Kubernetes sees this type with the `kubernetes.io/service-account.name` annotation, it
automatically populates the secret with:

- **token** - A JWT that can be used to authenticate as the service account
- **ca.crt** - The cluster's CA certificate
- **namespace** - The namespace of the service account

You can view the token (base64 decoded) with:

```bash
kubectl get secret demo-app-token -o jsonpath='{.data.token}' | base64 -d
```

This JWT is what Vault will validate when our workload tries to authenticate.

## Next Steps

We now have all the pieces in place:
- A secret in Vault at `secret/demo/config`
- A policy granting read access to that secret
- A role linking the `demo-app` service account to that policy
- A Kubernetes service account with a token

Before we configure the Vault Secrets Operator, let's manually test that authentication works.
This is a good troubleshooting skill - if VSO isn't working, you can use the same manual process
to diagnose where things are failing.
