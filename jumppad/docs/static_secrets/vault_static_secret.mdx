# Creating a VaultStaticSecret

Now that authentication is configured, and it has been tested. We can create a `VaultStaticSecret` to sync our demo secret from Vault to Kubernetes.

<Task id="create_static_secret">

## VaultStaticSecret Resource

The VaultStaticSecret resource tells the Vault Secrets Operator which secret to sync from Vault, how to authenticate, and where to store it in Kubernetes.

To create the resource, create a file called `k8s/vault-static-secret.yaml` with the following content and apply it using kubectl:

```yaml
apiVersion: secrets.hashicorp.com/v1beta1
kind: VaultStaticSecret
metadata:
  name: demo-secret
  namespace: default
spec:
  vaultAuthRef: demo-auth
  mount: secret
  path: demo/config
  type: kv-v2
  refreshAfter: 30s
  destination:
    name: demo-app-secret
    create: true
```

Key fields:
- **vaultAuthRef** - References our VaultAuth resource
- **mount** - The secrets engine mount path (`secret`)
- **path** - Path to the secret within the mount (`demo/config`)
- **type** - KV engine version (`kv-v2`)
- **refreshAfter** - How often to check for updates
- **destination.name** - Name of the Kubernetes secret to create

## Apply the Configuration

```bash
kubectl apply -f k8s/vault-static-secret.yaml
```

## Verify the Secret

Check that the Kubernetes secret was created:

```bash
kubectl get secret demo-app-secret -o jsonpath='{.data}' | jq -r 'to_entries[] | "\(.key): \(.value | @base64d)"'
```

</Task>

## Update the Secret in Vault

Try updating the secret in Vault:

```bash
vault kv put secret/demo/config \
  username="new-user" \
  password="new-password" \
  api_key="new-api-key"
```

Wait 30 seconds (the `refreshAfter` interval) and check the Kubernetes secret again - it should be updated!

That completes the process of syncing a static secret from Vault to Kubernetes using the Vault Secrets Operator. Next, let's look at how you can sync dynamic secrets like database credentials. 
