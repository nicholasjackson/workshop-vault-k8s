# Working with Secrets

Before we automate secret delivery to Kubernetes, it's important to understand how secrets
work in Vault by creating and managing them manually. This will help you understand what's
happening behind the scenes when the Vault Secrets Operator syncs secrets to your cluster.

## Understanding Secret Paths

In Vault, secrets are organized hierarchically using paths, similar to a filesystem. The path
has two parts:

- **Mount point** - The secrets engine location (e.g., `secret/`)
- **Path within the mount** - Your organizational structure (e.g., `demo/config`)

So the full path `secret/demo/config` means:
- `secret` - The KV v2 secrets engine mount point
- `demo/config` - A secret called "config" in the "demo" folder

You can organize secrets however makes sense for your organization. Common patterns include:
- By application: `secret/myapp/database`, `secret/myapp/api-keys`
- By environment: `secret/prod/database`, `secret/staging/database`
- By team: `secret/platform-team/aws`, `secret/frontend-team/stripe`

## Creating, Reading, and Updating Secrets

The `vault kv put` command stores key-value pairs at a path. For this workshop, we'll create
a secret that represents application configuration - the kind of credentials you might need
to inject into a Kubernetes pod.

One of the key advantages of using Vault over Kubernetes secrets directly is versioning. When
you update a secret, Vault doesn't overwrite the old value - it creates a new version. This
provides an audit trail and allows you to roll back if needed.

<Task id="working_with_secrets">

First, let's create a secret at `secret/demo/config` with some demo credentials:

```bash
vault kv put secret/demo/config \
  username="demo-user" \
  password="demo-password" \
  api_key="my-api-key-12345"
```

You should see output showing the secret was created with version 1. Notice that the actual
path includes `/data/`.

```bash
===== Secret Path =====
secret/data/demo/config
```
This is a KV v2 implementation detail that will be important when
we create policies later.

Now retrieve the secret you just created using the `vault kv get` command:

```bash
vault kv get secret/demo/config
```

The output shows metadata (version, creation time) and the actual key-value data you stored.

```bash
======= Metadata =======
Key                Value
---                -----
created_time       2026-01-15T09:59:17.277113146Z
custom_metadata    <nil>
deletion_time      n/a
destroyed          false
version            1

====== Data ======
Key         Value
---         -----
api_key     my-api-key-12345
password    demo-password
username    demo-user
```

Finally, let's update the secret with a new password to see versioning in action:

```bash
vault kv put secret/demo/config \
  username="demo-user" \
  password="new-secure-password" \
  api_key="my-api-key-12345"
```

If you run the `get` command again, you'll see the version number has incremented to 2:

```bash
======= Metadata =======
Key                Value
---                -----
created_time       2026-01-15T11:11:47.531731856Z
custom_metadata    <nil>
deletion_time      n/a
destroyed          false
version            2

====== Data ======
Key         Value
---         -----
api_key     my-api-key-12345
password    new-secure-password
username    demo-user
```

</Task>



## Working with Secret Data Programmatically

When integrating with scripts or applications, you'll often need to extract specific fields
or get the data in a machine-readable format.

To get just a single field value (useful in shell scripts):

```bash
vault kv get -field=password secret/demo/config
```

To get the full secret as JSON (useful for parsing with tools like `jq`):

```bash
vault kv get -format=json secret/demo/config
```

The JSON output includes both metadata and data, which you can extract with:

```bash
vault kv get -format=json secret/demo/config | jq -r '.data.data.password'
```

Note the double `.data.data` - the first `.data` is the response wrapper, and the second
`.data` contains your actual secret values.

## Next Steps

Now that we have a secret in Vault and understand how to work with it, we need to configure
access control. Currently, we're using the root token which has unlimited access - but your
Kubernetes workloads shouldn't have that level of privilege.

In the next section, we'll create a Vault policy that grants read-only access to our secret,
and a role that links Kubernetes service accounts to that policy.
